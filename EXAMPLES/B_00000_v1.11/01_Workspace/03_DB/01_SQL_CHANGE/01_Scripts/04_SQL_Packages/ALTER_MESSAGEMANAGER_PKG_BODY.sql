create or replace PACKAGE BODY ESB_MESSAGEMANAGER_PKG
AS
  PROCEDURE GETCAPABILITYCHECKSTATUS(
      p_SERVICE_CODE      IN VARCHAR2,
      p_SERVICE_NAME      IN VARCHAR2,
      p_SERVICE_OPERATION IN VARCHAR2,
      CHECK_MESSAGE OUT NUMBER,
      CAPABILITY_ID OUT NUMBER)
  IS
  BEGIN
    SELECT CC.CHECK_INDICATOR,
      C."ID"
    INTO CHECK_MESSAGE,
      CAPABILITY_ID
    FROM ESB_SERVICE S
    INNER JOIN ESB_CAPABILITY C
    ON C.SERVICE_ID = S.ID
    INNER JOIN ESB_CAPABILITY_CHECK CC
    ON CC.CAPABILITY_ID = C.ID
    WHERE S.CODE        = p_SERVICE_CODE
    AND S."NAME"        = p_SERVICE_NAME
    AND C."NAME"        = p_SERVICE_OPERATION
    AND C.RCD_STATUS    = 1
    AND S.RCD_STATUS    = 1
    AND CC.RCD_STATUS   = 1;
  EXCEPTION
  WHEN NO_DATA_FOUND THEN
    CHECK_MESSAGE := -1;
  END GETCAPABILITYCHECKSTATUS;
  PROCEDURE GETCAPABILITYCHECKS(
      p_SERVICE_CODE      IN VARCHAR2,
      p_SERVICE_NAME      IN VARCHAR2,
      p_SERVICE_OPERATION IN VARCHAR2,
      CHECK_TYPES OUT SYS_REFCURSOR)
  IS
  BEGIN
    OPEN CHECK_TYPES FOR SELECT CT.ID,
    CT."NAME",
    CT.GRADE,
    TO_CHAR(CCO.ELAPSED_TIME)
  AS
    ELAPSED_TIME,
    3
  AS
  TYPE FROM ESB_SERVICE S INNER JOIN ESB_CAPABILITY C ON C.SERVICE_ID = S.ID INNER JOIN ESB_CAPABILITY_CHECK CC ON CC.CAPABILITY_ID = C.ID INNER JOIN ESB_CHECK_CONFIG CCO ON CCO.CAP_CHK_ID = CC.ID INNER JOIN ESB_CHECK_TYPE CT ON CT.ID = CCO.CHECK_TYPE_ID WHERE S.CODE = p_SERVICE_CODE AND S."NAME" = p_SERVICE_NAME AND C."NAME" = p_SERVICE_OPERATION AND C.RCD_STATUS = 1 AND S.RCD_STATUS = 1 AND CC.RCD_STATUS = 1 AND CCO.RCD_STATUS = 1 AND CT.RCD_STATUS = 1 ORDER BY CT.GRADE DESC;
END GETCAPABILITYCHECKS;
  PROCEDURE GETDEFAULTCHECKS(
      p_CHECK_TYPE IN NUMBER,
      CHECK_TYPES OUT SYS_REFCURSOR)
  IS
  BEGIN
    OPEN CHECK_TYPES FOR SELECT "ID",
    "NAME",
    GRADE,
    TO_CHAR(ELAPSED_TIME)
  AS
    ELAPSED_TIME,
    "TYPE" FROM ESB_DEFAULT_CHECK WHERE "TYPE" = p_CHECK_TYPE AND RCD_STATUS = 1 ORDER BY "TYPE",
    GRADE DESC;
  END GETDEFAULTCHECKS;
  PROCEDURE GETMESSAGESTATUS(
      p_EVENT_ID             IN VARCHAR2,
      p_PROC_ID              IN VARCHAR2,
      p_CLIENT_REQ_TIMESTAMP IN TIMESTAMP WITH TIME ZONE,
      p_CAPABILITY_ID        IN NUMBER,
      MESSAGE_TRANSACTION OUT SYS_REFCURSOR)
  IS
  BEGIN
    OPEN MESSAGE_TRANSACTION FOR SELECT MT."ID",
    MT.PROC_ID,
    MT.EVENT_ID,
    TO_CHAR(MT.CLIENT_REQ_TIMESTAMP) CLIENT_REQ_TIMESTAMP,
    MT.STATUS,
    MT.MSG_TIMESTAMP,
    MT."SEQUENCE",
    TC.CAPABILITY_ID,
    MT.CREATIONDATE FROM ESB_MESSAGE_TRANSACTION MT INNER JOIN ESB_TRANSACTION_CHECK TC ON MT.ID = TC.MESSAGE_TX_ID WHERE MT.EVENT_ID = p_EVENT_ID AND MT.PROC_ID = p_PROC_ID AND MT.CLIENT_REQ_TIMESTAMP = p_CLIENT_REQ_TIMESTAMP AND TC.CAPABILITY_ID = p_CAPABILITY_ID AND MT.RCD_STATUS = 1 ORDER BY MT."SEQUENCE" ASC;
  END GETMESSAGESTATUS;
  PROCEDURE GETTRANSACTIONINFO(
      p_EVENT_ID             IN VARCHAR2,
      p_PROC_ID              IN VARCHAR2,
      p_CLIENT_REQ_TIMESTAMP IN TIMESTAMP WITH TIME ZONE,
      p_CAPABILITY_ID        IN NUMBER,
      p_CORRELATION_ID       IN VARCHAR2,
      MESSAGE_TRANSACTION OUT SYS_REFCURSOR)
  IS
  BEGIN
    OPEN MESSAGE_TRANSACTION FOR SELECT MT."ID",
    MT.STATUS,
    MT.MSG_TIMESTAMP,
    TC.CAPABILITY_ID,
    MT."SEQUENCE",
    MT.CORRELATION_ID
    FROM ESB_MESSAGE_TRANSACTION MT INNER JOIN ESB_TRANSACTION_CHECK TC ON MT.ID = TC.MESSAGE_TX_ID WHERE MT.EVENT_ID = p_EVENT_ID AND MT.PROC_ID = p_PROC_ID AND -- MT.CORRELATION_ID = p_CORRELATION_ID AND TC.CAPABILITY_ID = p_CAPABILITY_ID AND 
    --MT.CLIENT_REQ_TIMESTAMP = p_CLIENT_REQ_TIMESTAMP AND ||| Sacamos esto para evitar tomar el CLIENT_REQ_TIMESTAMP como clave para determinar un mensaje duplicado.
    MT.RCD_STATUS = 1 ORDER BY MT."SEQUENCE" DESC;
  END GETTRANSACTIONINFO;
  PROCEDURE GETCHECKTRANSACTION(
      p_EVENT_ID             IN VARCHAR2,
      p_PROC_ID              IN VARCHAR2,
      p_CLIENT_REQ_TIMESTAMP IN TIMESTAMP WITH TIME ZONE,
      p_CAPABILITY_ID        IN NUMBER,
      TRANSACTION_CHECK OUT SYS_REFCURSOR)
  IS
  BEGIN
    OPEN TRANSACTION_CHECK FOR SELECT MT.PROC_ID,
    MT.EVENT_ID,
    TO_CHAR(MT.CLIENT_REQ_TIMESTAMP) CLIENT_REQ_TIMESTAMP,
    MT.STATUS,
    TC.CONVERSATION_ID,
    TC.RSP_MSG,
    TC.RESULT_CODE,
    TC.RESULT_DESC FROM ESB_MESSAGE_TRANSACTION MT INNER JOIN ESB_TRANSACTION_CHECK TC ON TC.MESSAGE_TX_ID = MT.ID WHERE MT.EVENT_ID = p_EVENT_ID AND MT.PROC_ID = p_PROC_ID AND
    --MT.CLIENT_REQ_TIMESTAMP = p_CLIENT_REQ_TIMESTAMP AND ||| Sacamos esto para evitar tomar el CLIENT_REQ_TIMESTAMP como clave para determinar un mensaje duplicado (en este caso para que encuentre el registro,
    --. Si el flujo desde OSB llega a este punto, significa que se considera la Tx procesada como equivalente a alguna existente en ESB_MESSAGE_TRANSACTION. Si dejamos este campo aqui, validaciones que dependan
    -- de este SP estarian retornando datos de Tx que cumplan tambien con el mismo CLIENT_REQ_TIMESTAMP lo que carece de sentido una vez no considerado este campo como parte de la KEY.).
    TC.CAPABILITY_ID = p_CAPABILITY_ID AND MT.RCD_STATUS = 1 AND TC.RCD_STATUS = 1 ORDER BY MT."SEQUENCE" ASC;
  END GETCHECKTRANSACTION;
  PROCEDURE REGISTRYTRANSACTION(
      p_EVENT_ID             IN VARCHAR2,
      p_PROC_ID              IN VARCHAR2,
      p_CLIENT_REQ_TIMESTAMP IN VARCHAR2,
      p_CAPABILITY_ID        IN NUMBER,
      p_CONVERSATION_ID      IN VARCHAR2,
      p_CORRELATION_ID       IN VARCHAR2,
      RESULT_ID OUT NUMBER)
  IS
  BEGIN
  
  
    INSERT
    INTO ESB_MESSAGE_TRANSACTION
      (
        ID,
        PROC_ID,
        EVENT_ID,
        STATUS,
        RCD_STATUS,
        CLIENT_REQ_TIMESTAMP,
        MSG_TIMESTAMP,
        "SEQUENCE",
        CORRELATION_ID
      )
      VALUES
      (
        ESB_MESSAGE_TRANSACTION_SEQ.NEXTVAL,
        p_PROC_ID,
        p_EVENT_ID,
        0,
        1,
        TO_TIMESTAMP_TZ(p_CLIENT_REQ_TIMESTAMP,'YYYY-MM-DD HH24:MI:SS TZH:TZM'),
        CURRENT_TIMESTAMP,
        --Si no encuentra una transaccion a partir de PROC_ID + EVENT_ID + CORRELATION_ID, siendo un segmento e la TX, 
        --se genera una transacion con SEQUENCE + 1 del PROC_ID + EVENT_ID (Si no encuentra transaccion, va a generar la de SEQUENCE = 0)
        (SELECT count(*) FROM ESB_MESSAGE_TRANSACTION MT WHERE MT.PROC_ID = p_PROC_ID AND MT.EVENT_ID = p_EVENT_ID),
        p_CORRELATION_ID
      )
    RETURNING "ID"
    INTO RESULT_ID;
    INSERT
    INTO ESB_TRANSACTION_CHECK
      (
        ID,
        MESSAGE_TX_ID,
        CONVERSATION_ID,
        CAPABILITY_ID,
        RCD_STATUS
      )
      VALUES
      (
        ESB_TRANSACTION_CHECK_SEQ.NEXTVAL,
        RESULT_ID,
        p_CONVERSATION_ID,
        p_CAPABILITY_ID,
        1
      );
    COMMIT;
  EXCEPTION
  WHEN OTHERS THEN
    RESULT_ID:= -1;
    ROLLBACK;
  END REGISTRYTRANSACTION;
   PROCEDURE UPDATETRANSACTION
    (
      p_EVENT_ID             IN VARCHAR2,
      p_PROC_ID              IN VARCHAR2,
      p_CORRELATION_ID       IN VARCHAR2,
      p_CLIENT_REQ_TIMESTAMP IN VARCHAR2,
      p_CAPABILITY_ID        IN NUMBER,
      p_NEWSTATUS            IN NUMBER,
      RESULT_ID OUT NUMBER
    )
  IS
  BEGIN
    UPDATE ESB_MESSAGE_TRANSACTION MT
    SET MT.STATUS     = p_NEWSTATUS
    WHERE MT.EVENT_ID = p_EVENT_ID
    AND MT.PROC_ID    = p_PROC_ID
    AND COALESCE(MT.CORRELATION_ID, './*@*') = COALESCE(p_CORRELATION_ID , './*@*')
    AND
      --MT.CLIENT_REQ_TIMESTAMP = TO_TIMESTAMP_TZ(p_CLIENT_REQ_TIMESTAMP,'YYYY-MM-DD HH24:MI:SS TZH:TZM') AND ||| Sacamos esto para evitar tomar el CLIENT_REQ_TIMESTAMP como clave para determinar un mensaje duplicado (en este caso para que encuentre el registro,
      --. Si el flujo desde OSB llega a este punto (checkOUT), significa que la Tx fue registrada por la misma instancia solicitante (no ERA duplicada al checkIN). Si dejamos este campo aqui, validaciones que dependan
      -- de este SP estarian actualizando datos de Tx que cumplan tambien con el mismo CLIENT_REQ_TIMESTAMP lo que carece de sentido una vez no considerado este campo como parte de la KEY.).
      p_CAPABILITY_ID =
      (SELECT CAPABILITY_ID
      FROM ESB_TRANSACTION_CHECK TC
      WHERE TC.MESSAGE_TX_ID = MT.ID
      ) RETURNING MT."ID"
    INTO RESULT_ID;
  END UPDATETRANSACTION;
  PROCEDURE REGISTRYTRANSACTIONCHECK(
      p_MESSAGE_TX_ID   IN NUMBER,
      p_CONVERSATION_ID IN VARCHAR2,
      p_RESPONSE_MSG    IN CLOB,
      p_RESULT_CODE     IN VARCHAR2,
      p_RESULT_DESC     IN VARCHAR2,
      RESULT_ID OUT NUMBER)
  IS
  BEGIN
    UPDATE ESB_TRANSACTION_CHECK
    SET CONVERSATION_ID = p_CONVERSATION_ID,
      RSP_MSG           = p_RESPONSE_MSG,
      RESULT_CODE       = p_RESULT_CODE,
      RESULT_DESC       = p_RESULT_DESC
    WHERE MESSAGE_TX_ID = p_MESSAGE_TX_ID RETURNING "ID"
    INTO RESULT_ID;
  EXCEPTION
  WHEN OTHERS THEN
    raise_application_error(-20100,'Error insertando transaccion');
  END REGISTRYTRANSACTIONCHECK;
  
END ESB_MESSAGEMANAGER_PKG;